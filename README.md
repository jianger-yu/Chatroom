---
# 聊天室系统用户文档
---

## 部署与运行指南

### 1. 环境准备

* Linux系统（推荐 Ubuntu、CentOS 等）
* 安装Redis服务并以项目内redis.conf配置文件启动
* 确保C++编译环境（支持C++11及以上）
* 若缺少依赖，请运行项目根目录下的安装依赖脚本：

```bash
./install_dependencies.sh
```
**该脚本提供以下依赖：**
* **build-essential**：提供编译工具，支持C++代码编译。
* **libc6-dev**：C语言标准库开发包。
* **libhiredis-dev**：与 Redis 进行通信的客户端库。
* **libsodium-dev**：用于加密和解密功能的库。
* **libcurl4-openssl-dev**：用于发送邮件的网络请求库。
* **libgoogle-glog-dev**：clog日志库，用于记录日志信息。

---

### 2. 获取代码

```bash
git clone git@github.com:jianger-yu/Chatroom.git
cd Chatroom
```

---

### 3. 启动服务器

```bash
./start_server.sh [ip] [port]
```

* 启动主Reactor监听连接
* 自动启动若干从Reactor线程负责事件处理
* 可选指定IP和端口，不传默认使用配置文件内设定

---

### 4. 启动客户端

```bash
./start_client.sh [ip] [port]
```

* CLI界面，连接服务器指定地址及端口
---
## 项目架构
![alt text](server_client.drawio.png)
---

## 1. 系统环境与架构

* **操作系统**：Linux（推荐 Ubuntu、CentOS 等）
* **运行环境**：终端命令行（CLI），支持远程SSH操作
* **架构特点**：

  * **主从Reactor模式**设计，主Reactor负责监听客户端连接事件，从Reactor负责处理已连接客户端的读写事件
  * 每个Reactor均采用**epoll ET（边缘触发）模式**实现高效I/O多路复用
  * 结合多线程技术，提升服务器高并发连接处理能力
* **数据存储**：使用Redis数据库，结合JSON序列化/反序列化实现高效数据存取
* **通信协议**：基于TCP，支持心跳检测保证连接稳定

---

## 2. 主要功能概览

### 2.1 用户管理

* 用户注册、登录、注销
* 验证码注册与密码找回（邮箱/手机号）
* 用户数据加密处理，保障信息安全

### 2.2 好友系统

* 好友添加、删除及查询
* 在线状态显示，屏蔽非好友私聊
* 好友消息屏蔽设置

### 2.3 群组管理

* 群组创建、解散
* 申请加入及审批流程
* 群成员管理（查看列表、退出群组）
* 群主和管理员权限管理（添加管理员、移除成员）

### 2.4 聊天功能

* 好友间私聊、群聊
* 在线及离线消息同步，离线消息通知
* 聊天记录查看（历史消息）
* 实时消息通知（好友请求、私聊、加群申请等）

### 2.5 文件传输

* 在线用户间文件发送
* 支持离线用户接收文件，登录后获得通知并下载

### 2.6 系统性能与稳定性

* 多线程主从Reactor配合epoll ET，支持海量并发连接
* TCP心跳检测，实时维护连接健康状态，及时断开异常连接
* 服务器日志记录系统状态及异常，便于运维
---

## 3. 用户使用说明

* 客户端提供完整操作指引，包含注册、登录、加好友、聊天、建群等流程
* 所有聊天及文件传输均实时反馈状态和通知
* 离线消息及文件将在用户重新上线时自动推送

---

## 4. 关键技术亮点

* **主从Reactor模型**设计，解耦监听和读写，提升服务器性能和响应速度
* **epoll ET模式**实现高效事件通知，降低系统调用频率
* **心跳机制**保证长连接稳定，自动检测异常断开
* **Redis存储**支持快速数据存取及多客户端同步
* **多线程安全**设计，保证数据一致性和系统稳定性

---

## 5. 维护与注意事项

* 请保持Redis服务正常运行
* 网络异常时，客户端可能会被心跳机制断线，需重连
* 关闭服务器前，请先通知在线用户，确保数据完整

---

## 6. 未来改进方向
* 支持客户端图形界面（GUI）
* 增强数据加密和安全认证
* 支持移动端客户端
* 优化群组管理及消息推送效率
---

## 答辩不熟悉问题与拓展内容的学习

### 1.无锁队列
无锁队列是一种并发数据结构，它允许多个线程并行地执行操作而不需要使用传统的锁机制（如互斥锁）。无锁队列的核心思想是在多线程环境下，通过利用 CPU 的原子操作来保证数据结构的一致性，而无需让线程互相等待或进行阻塞。无锁队列能够有效减少上下文切换和锁竞争带来的性能损失，因此在高并发场景下非常有用。在我的项目中，可用无锁队列来优化客户端的MessageQueue，更适合应对高并发场景。

#### 无锁队列的关键特性：

1. **原子操作**：无锁队列通过原子操作来保证并发访问的一致性。这些操作是由硬件提供的，能够在一个不可分割的步骤内完成，避免了传统锁机制的开销。

2. **非阻塞性**：由于没有使用锁，无锁队列不会导致线程阻塞或产生死锁。线程即使没有获取到资源，也可以继续执行其他任务，不会被迫等待。

3. **避免上下文切换**：传统锁可能会导致上下文切换，而无锁数据结构通过原子操作直接修改共享数据，避免了线程的切换，从而提高了性能。

4. **高并发支持**：无锁队列在多核处理器的环境中尤其有优势，因为它能有效利用多核的并行性，不需要竞争锁资源。

#### 无锁队列的实现原理：

无锁队列一般基于以下几种实现模式：

##### 1. **单向链表**

这种无锁队列的设计使用单链表来存储元素。通常我们会为队列设计一个头指针（head）和尾指针（tail），并使用原子操作来维护这两个指针的更新。常见的实现方式是使用`CAS`操作来保证队列的元素在并发访问下的一致性。

##### 2. **环形缓冲区**

环形缓冲区是一种固定大小的无锁队列，它使用固定大小的数组和两个指针（头指针和尾指针）来表示队列的起始位置和结束位置。环形缓冲区的好处是，它不需要动态内存分配，因此比动态链表更节省内存开销。


#### 典型实现（基于链表）：

一个典型的无锁队列可能看起来像这样：

```cpp
#include <atomic>
#include <iostream>

template <typename T>
class LockFreeQueue {
private:
    struct Node {
        T data;
        Node* next;
        Node(T value) : data(value), next(nullptr) {}
    };
    
    std::atomic<Node*> head;
    std::atomic<Node*> tail;

public:
    LockFreeQueue() {
        Node* nnode = new Node(T()); // 创建一个空节点作为头部
        head.store(nnode);
        tail.store(nnode);
    }

    void push(T value) {
        Node* newNode = new Node(value);
        Node* prevTail = tail.load();
        
        // 尝试更新尾部节点的next指针
        while (!std::atomic_compare_exchange_weak(&prevTail->next, &prevTail->next, newNode)) {
            prevTail = tail.load();
        }
        
        // 更新尾指针
        tail.store(newNode);
    }

    bool get(T& value) {
        Node* prevHead = head.load();
        
        // 检查队列是否为空
        if (prevHead->next == nullptr) {
            return false; // 队列为空
        }
        
        Node* newHead = prevHead->next;
        value = newHead->data;
        
        // 更新头指针
        head.store(newHead);
        delete prevHead;
        return true;
    }
};
```

#### 关键点：

* `push` 操作：通过 `std::atomic_compare_exchange_weak` 确保将新的节点附加到队列尾部。
* `get` 操作：通过更新 `head` 指针并删除旧的头节点来实现出队。

#### 优点：

1. **高并发性能**：在多个线程同时访问队列时，避免了锁的竞争，提供了更高的吞吐量和响应时间。
2. **避免死锁**：由于没有锁，无锁队列不会陷入死锁或优先级反转问题。
3. **非阻塞**：线程在执行入队或出队操作时不会被阻塞，能有效利用多核 CPU 的并行性。

---

### 2.哈希表的扩容
#### 两种主要的哈希冲突解决方式：

1. **链式哈希法（Separate Chaining）**：

   * 在这种方式下，每个桶（即哈希表中的每个位置）存储一个链表或其他数据结构（如红黑树）来存放多个哈希值相同的元素。
   * **扩容时的处理**：

     * 创建一个新的、较大的哈希表。
     * 对于原哈希表中的每个元素，根据新的表大小重新计算其哈希值，并将其插入到新的哈希表中。
     * 链表会保持原来的元素顺序，但是需要重新将每个元素链接到新的哈希表的对应位置。
     * 这种方式扩容时的主要操作是将元素重新哈希并插入新表。

   **示例**：

   ```cpp
   // 新表大小为原表的两倍
   size_t new_size = old_size * 2;
   std::vector<std::list<KeyValue>> new_table(new_size);

   for (const auto& bucket : old_table) {
       for (const auto& kv : bucket) {
           size_t new_index = hash(kv.key) % new_size;
           new_table[new_index].push_back(kv);
       }
   }
   ```

2. **开放寻址法（Open Addressing）**：

   * 在这种方式下，所有的元素都存储在哈希表的数组中，遇到冲突时，使用探测（如线性探测、二次探测或双重哈希）来查找下一个空槽。
   * **扩容时的处理**：

     * 创建一个新的、更大的哈希表。
     * 重新计算所有元素的哈希值，并将它们插入到新表中。由于探测方式改变，插入位置也会发生变化，因此必须将元素重新插入新表。
     * 扩容时一般也会增加探测步数的长度，避免新的哈希表中依旧发生过多的冲突。

   **示例**：

   ```cpp
   // 新表大小为原表的两倍
   size_t new_size = old_size * 2;
   std::vector<KeyValue> new_table(new_size);

   for (const auto& kv : old_table) {
       if (kv != empty_slot) {
           size_t index = hash(kv.key) % new_size;
           while (new_table[index] != empty_slot) {
               index = (index + 1) % new_size;  // 线性探测
           }
           new_table[index] = kv;
       }
   }
   ```

#### 扩容时的注意事项：

1. **重新计算哈希值**：
   无论使用链式哈希法还是开放寻址法，扩容时都需要重新计算每个元素的哈希值。这是因为哈希表的大小发生了变化，原有的哈希值可能不再适用。

2. **用倍数增加容量而非简单增长**：
   扩容时直接将哈希表大小加倍是比较常见的策略，但也有一些哈希表实现会按照特定的增长因子进行扩容。增长因子的选择直接影响哈希表的性能和扩容的次数。

3. **选择适当的哈希函数**：
   扩容时，选择一个好的哈希函数是至关重要的。若哈希函数在扩容后依然存在较多冲突，那么扩容效果可能不理想。为了提高哈希表性能，应该选择均匀分布的哈希函数，避免过多的冲突。

4. **扩容的时机**：
   扩容通常在哈希表的负载因子超过一定阈值时触发（例如负载因子 > 0.75）。这意味着表中大部分桶都已经被占用，扩容可以降低冲突率，提高查找效率。负载因子（load factor）是哈希表中元素的数量与哈希表容量的比值。

5. **性能考虑**：
   扩容操作涉及重新计算所有元素的哈希值并插入新表，这个操作的时间复杂度是 O(n)，其中 n 是哈希表中的元素数。所以扩容通常会影响性能。为了减少扩容的频率，一些哈希表的实现采用**渐进式扩容**策略，也就是在每次插入新元素时逐渐扩容。

#### 总结：

* **链式哈希法**扩容时，主要是创建新哈希表并将原有元素重新哈希到新表中，每个桶内部的冲突处理不受影响。
* **开放寻址法**扩容时，不仅需要重新哈希元素，还需要根据探测方法来重新插入元素。

---

### 3.二叉搜索树的基础与构造
在一个**普通二叉树**（也叫**一般二叉树**）中，**节点之间没有大小关系**。与特定类型的二叉树（如**二叉搜索树**）不同，普通二叉树的节点只是根据**结构**来组织的，而不是根据节点值的大小关系来组织的。

#### 普通二叉树的特征：

1. **没有特定的大小限制**：每个节点的值可以是任意的，左子树或右子树的节点的值并不受限制。
2. **结构自由**：普通二叉树的结构可以是任意的，不一定是平衡的，节点的左右子树没有任何约束。
3. **没有排序规则**：不像二叉搜索树，普通二叉树的节点值可以任意排序，没有像二叉搜索树那样的大小关系要求。

#### 二叉搜索树（BST）
二叉搜索树是一种特殊的二叉树，其节点值满足以下性质：

1. 左子树的所有节点值都小于根节点的值。
2. 右子树的所有节点值都大于根节点的值。
3. 对于每一个子树，这个规则也必须成立。即左子树和右子树都是二叉搜索树。

* **增**
  ```cpp
  TreeNode* insert(TreeNode* root, int val) {
      if (root == nullptr) {
          return new TreeNode(val);  // 如果根节点为空，创建新节点
      }
      if (val < root->val) {
          root->left = insert(root->left, val);  // 在左子树插入
      } else {
          root->right = insert(root->right, val); // 在右子树插入
      }
      return root;
  }
  ```
* **查**
  ```cpp
    TreeNode* search(TreeNode* root, int val) {
        if (root == nullptr || root->val == val) {
            return root;
        }
        if (val < root->val) {
            return search(root->left, val);  // 在左子树查找
        } else {
            return search(root->right, val); // 在右子树查找
        }
    }
  ```
* **删**
  ```cpp
  TreeNode* deleteNode(TreeNode* root, int val) {
      if (root == nullptr) {
          return root;
      }
      if (val < root->val) {
          root->left = deleteNode(root->left, val);  // 在左子树删除
      } else if (val > root->val) {
          root->right = deleteNode(root->right, val); // 在右子树删除
      } else {  // 找到要删除的节点
          // 1. 节点没有子节点
          if (root->left == nullptr && root->right == nullptr) {
              delete root;
              return nullptr;
          }
          // 2. 节点有一个子节点
          else if (root->left == nullptr) {
              TreeNode* temp = root->right;
              delete root;
              return temp;
          } else if (root->right == nullptr) {
              TreeNode* temp = root->left;
              delete root;
              return temp;
          }
          // 3. 节点有两个子节点，找后继节点
          else {
              TreeNode* temp = minValueNode(root->right);  // 找右子树中的最小节点（后继节点）
              root->val = temp->val;  // 用后继节点的值替换当前节点
              root->right = deleteNode(root->right, temp->val);  // 删除后继节点
          }
      }
      return root;
  }
  ```
通过这些操作，二叉搜索树能够支持高效的查找、插入和删除，通常时间复杂度为 O(log n)，但在最坏情况下（如退化为链表）可能退化为 O(n)。

---

### 4. AVL树
**AVL树**是一种**自平衡的二叉搜索树**，它保证了每个节点的左右子树的高度差（平衡因子）最多为1，从而保持树的高度为对数级别（O(log n)），确保查找、插入和删除操作的时间复杂度为 O(log n)。

#### 核心特点：

1. **二叉搜索树性质**：每个节点的左子树所有节点值小于该节点，右子树所有节点值大于该节点。
2. **平衡性要求**：每个节点的左右子树高度差（平衡因子）为 `-1`, `0` 或 `1`，否则进行旋转调整。

#### 旋转操作：

1. **右旋**（用于**左左**情况）。
2. **左旋**（用于**右右**情况）。
3. **左右旋**（用于**左右**情况）。
4. **右左旋**（用于**右左**情况）。

#### 时间复杂度：

* **查找、插入、删除**：O(log n)，由于平衡树的高度限制。

#### 总结：

AVL树通过旋转保持平衡，确保在执行基本操作时，始终具有较高的效率。

#### 与红黑树的对比

这里是 **红黑树** 和 **AVL树** 的精简对比表格：

| 特性        | **AVL树**                   | **红黑树**               |
| --------- | -------------------------- | --------------------- |
| **平衡性**   | 严格平衡，每个节点的平衡因子为 `-1, 0, 1` | 松散平衡，每个节点有红色或黑色约束     |
| **高度差限制** | 左右子树高度差 ≤ 1                | 没有严格的高度差限制            |
| **插入和删除** | 插入/删除后需要较多旋转来恢复平衡          | 插入/删除后通过旋转和着色操作恢复平衡   |
| **旋转次数**  | 最多需要 2 次旋转                 | 最多需要 2 次旋转            |
| **查找操作**  | 查找操作时间复杂度 O(log n)         | 查找操作时间复杂度 O(log n)    |
| **树的高度**  | 较小，严格平衡，适合查找频繁的应用          | 较大，但允许较松散的平衡，适合频繁插入删除 |
| **实现复杂度** | 较高，涉及更多的旋转操作和高度更新          | 相对较简单，旋转较少，着色操作较容易    |
| **适用场景**  | 查找操作频繁的场景，要求高度平衡           | 插入、删除操作频繁的场景，适合动态更新   |
| **优点**    | 查找效率高，树的高度更小               | 插入和删除效率高，旋转操作较少       |
| **缺点**    | 插入和删除时平衡维护复杂，旋转较多          | 查找效率稍差，树的高度较大         |

* **AVL树**适合查找频繁、对性能要求高的场景。
* **红黑树**更适合频繁插入和删除的应用，如 **Map** 和 **Set**。


### 5. 关于进程、线程、TCP的基本概念
#### (1) 进程
##### 概念
进程是正在执行的程序实例。执行程序时，内核会将程序代码载入虚拟内存，为程序变量分配空间，建立内核记账（bookkeeping）数据结构，以记录与进程有关的各种信息（比如，进程 ID、用户 ID、组 ID 以及终止状态等）。它是资源分配的基本单位，操作系统管理的基本单位。
在内核看来，进程是一个个实体，内核必须在它们之间共享各种计算机资源。对于像内存这样的受限资源来说，内核一开始会为进程分配一定数量的资源，并在进程的生命周期内，统筹该进程和整个系统对资源的需求，对这一分配进行调整。程序终止时，内核会释放所有此类资源，供其他进程重新使用。其他资源（如 CPU、网络带宽等）都属于可再生资源，但必须在所有进程间平等共享。

* **特点**：

  * 每个进程都有自己独立的内存空间、代码段、数据段等。
  * 进程间相互独立，不共享内存。
  * 每个进程至少有一个线程。
* **状态**：新建、就绪、运行、阻塞、终止。

#### (2) 线程
##### 概念
线程是进程中的执行单元。每个进程都可执行多个线程。可将线程想象为共享同一虚拟内存及一干其他属性的进程。每个线程都会执行相同的程序代码，共享同一数据区域和堆。可是，每个线程都拥有属于自己的栈，用来装载本地变量和函数调用链接信息。
* **特点**：

  * 线程与进程相比是更小的调度单位，多个线程共享同一进程的资源（如内存空间、文件句柄等）。
  * 线程之间相互独立，能够并发执行。
* **多线程**：

  * **用户级线程**：由用户程序管理。
  * **内核级线程**：由操作系统管理。
##### 线程同步

由于多个线程共享资源，可能会出现资源冲突，线程同步机制保证线程安全。常见的同步机制包括：

* **互斥锁（Mutex）**：保证同一时刻只有一个线程可以访问共享资源，避免竞争条件。
* **条件变量（Condition Variable）**：线程在满足特定条件时进行同步，常用于生产者-消费者问题。
* **读写锁（Read-Write Lock）**：允许多个线程同时读取资源，但写操作是互斥的，适用于读多写少的场景。
* **原子操作（Atomic Operations）**：确保操作不可中断，适用于简单的共享资源更新。

合理的同步机制可以确保多线程程序的正确性与效率。


#### (3) TCP
TCP 是一种面向连接、可靠的传输层协议，确保数据在网络中可靠传输。

##### **【1】 特点**

* **面向连接**：在数据传输开始前，TCP会先通过**三次握手**建立连接，确保通信双方都准备好进行数据传输。

* **可靠性**：TCP通过**序列号**、**确认应答（ACK）**和**重传机制**确保数据的可靠传输。

  * **序列号**：每个TCP段都有一个序列号，用来确保数据的顺序正确。
  * **确认应答（ACK）**：接收方发送确认消息，告知发送方已成功收到数据。
  * **重传机制**：如果发送方没有收到确认，它会在超时后重发数据。

* **流量控制**：TCP采用**滑动窗口机制**来控制数据流的速率，避免发送方超速导致接收方的缓存溢出。

  * **窗口大小**：接收方根据自己的接收能力，告知发送方当前可以接收的数据量。

* **拥塞控制**：TCP还实现了**拥塞控制**，来防止网络过载，主要通过以下机制：

  * **慢启动**：TCP连接刚开始时，慢慢增加数据发送速率。
  * **拥塞避免**：一旦网络拥塞被检测到，TCP会减少发送速率。
  * **快速重传**：如果某个数据包丢失，发送方会立即重发丢失的数据包，而不等待超时。
  * **快速恢复**：在检测到丢包后，TCP会进入快速恢复阶段，减少数据传输速率。

##### **【2】 三次握手（TCP连接建立）**

三次握手是TCP协议建立连接时的过程，确保双方可以安全、可靠地进行数据传输：

1. **SYN**：客户端发送一个SYN包（同步包），请求建立连接，序列号为 `x`。
2. **SYN-ACK**：服务器收到SYN包后，发送一个SYN-ACK包，表示同意建立连接，并将自己的序列号设置为 `y`，客户端的序列号 `x` 确认应答。
3. **ACK**：客户端收到SYN-ACK包后，发送一个ACK包，确认服务器的序列号 `y`，并回复序列号 `x+1`，此时连接建立。

##### **【3】 四次挥手（TCP连接断开）**

TCP断开连接是通过四次挥手过程来实现，确保双方都能正确地终止连接，防止数据丢失。

1. **FIN**：发送方发送一个FIN包，表示它已经没有数据要发送了，进入**半关闭状态**。
2. **ACK**：接收方收到FIN包后，确认并发送一个ACK包，表示它已收到终止请求，等待其自身的关闭。
3. **FIN**：接收方发送一个FIN包，表示它也没有数据要发送了。
4. **ACK**：发送方收到接收方的FIN包后，确认并发送ACK包，至此连接完全断开。

##### **【4】 TCP的拥塞控制与流量控制**

* **流量控制**：TCP通过滑动窗口机制控制数据的传输速率，防止接收方的缓存溢出。窗口大小根据接收方的缓冲区容量动态变化。

* **拥塞控制**：

  * **慢启动**：连接初期，发送窗口大小从一个小值开始，随着网络条件的良好逐步增大。
  * **拥塞避免**：当发送窗口增大到一定程度时，进入拥塞避免阶段，进一步的窗口增大将变得更加缓慢。
  * **快重传和快恢复**：一旦发送方丢包，会通过快速重传机制迅速重新发送丢失的数据包，并进入快速恢复阶段调整传输速率。

##### **【5】 TCP头部结构**

TCP的头部结构包含多个字段，用来支持它的功能。每个字段都在传输过程中扮演着关键角色。重要字段包括：

* **源端口和目的端口**：用于区分不同的应用程序。
* **序列号和确认号**：保证数据的顺序性与确认。
* **数据偏移**：指示数据从TCP报文段头部开始的位置。
* **标志位（SYN、ACK、FIN等）**：用于控制连接的建立与关闭。
* **窗口大小**：流量控制，指示接收方可以接收的字节数。
* **校验和**：用于错误检测，确保数据在传输过程中没有发生错误。

##### **【6】 TCP的可靠性保证机制**

* **顺序交付**：数据按照发送顺序到达接收方，TCP通过序列号确保数据顺序。
* **错误检测与重传**：数据包丢失时，通过重传机制保证数据的可靠传输。
* **完整性校验**：每个TCP段都包含校验和，用于检查数据是否在传输过程中发生损坏。

##### **【7】 TCP与UDP的比较**

| 特性       | **TCP**             | **UDP**         |
| -------- | ------------------- | --------------- |
| **连接方式** | 面向连接（建立连接）          | 无连接（直接发送数据）     |
| **可靠性**  | 提供可靠的数据传输（重传、确认、校验） | 不可靠，数据可能丢失      |
| **速度**   | 较慢（因要确认与重传）         | 较快（没有建立连接与确认过程） |
| **数据顺序** | 保证数据按顺序到达           | 不保证顺序           |
| **应用场景** | 文件传输、网页浏览、电子邮件等     | 流媒体、在线游戏、实时通讯等  |

---

### 6. 进程通信
进程间通信是指在不同进程之间交换数据或信号的机制。操作系统提供了多种方法来实现进程间的通信，以下是六种常见的进程通信方式：

#### (1) **管道（Pipe）**

* **定义**：管道是一种允许在相关进程之间传递数据的通信机制。数据流是单向的，数据从写端流向读端。
* **类型**：

  * **匿名管道**：通常用于父子进程或兄弟进程之间的通信。它不支持在不相关的进程之间使用。
  * **命名管道**（FIFO）：支持不相关的进程之间进行通信。通过给管道命名，多个进程可以打开并使用同一个管道。
* **特点**：

  * 数据是按顺序流动的，保证了通信的顺序性。
  * 只能传输字节流，不支持结构化数据。
* **应用场景**：用于同一程序的不同部分或父子进程之间的数据传输。

#### (2) **消息队列**

* **定义**：消息队列是一种先进先出（FIFO）的数据结构，允许多个进程通过队列交换消息。
* **特点**：

  * 可以存储结构化数据，支持消息的排队。
  * 支持异步通信，进程可以选择是否阻塞。
  * 支持多对多通信，多个进程可以同时写入或读取消息队列。
* **应用场景**：常用于需要传递结构化数据或需要异步通信的系统中，如消息系统、任务队列等。

#### (3) **共享内存**

* **定义**：共享内存是一种允许多个进程访问同一块物理内存区域的通信方式，数据直接存储在内存中，无需复制数据。
* **特点**：

  * 高效，因为进程可以直接访问内存而无需通过内核复制数据。
  * 需要显式的同步机制，如信号量或互斥锁，避免竞争条件。
  * 适用于需要大规模数据交换的进程间通信。
* **应用场景**：大型数据处理、视频流传输等高效通信场景。

#### (4) **信号量**

* **定义**：信号量是一种同步机制，用于进程间的协调与互斥。它通常用于解决进程之间的同步问题，而不是直接的数据交换。
* **特点**：

  * 常用于控制访问共享资源，防止数据竞争。
  * 可用于信号的传递，通过改变信号量的值来通知其他进程。
  * 有二值信号量（0或1，用于互斥）和计数信号量（任意非负值，用于控制资源数量）。
* **应用场景**：多进程控制访问共享资源、实现生产者消费者问题等。

#### (5) **套接字（Socket）**

* **定义**：套接字是一个用于不同主机间或同一主机内不同进程间进行网络通信的接口。它允许进程通过网络协议交换数据。
* **特点**：

  * 可以是**流式套接字**（TCP）或**数据报套接字**（UDP），支持可靠或不可靠的通信。
  * 支持进程间通信的同时，也支持跨网络通信。
  * 支持客户端-服务器模式。
* **应用场景**：网络应用、分布式系统、客户端-服务器通信等。

#### (6) **内存映射**

* **定义**：内存映射允许进程将文件的内容映射到进程的虚拟地址空间，进程通过直接访问内存来读写文件，从而实现高效的进程间通信。
* **特点**：

  * 可以用于不同进程之间共享文件数据，进程通过直接操作内存来共享数据。
  * 高效，因为不需要通过内核进行数据复制。
  * 必须显式同步，防止多个进程同时修改同一内存区域。
* **应用场景**：用于共享大文件或数据结构的高效处理，如数据库缓存、图像处理等。

#### (7) **总结对比表**：

| 方法       | 特点               | 适用场景             | 优缺点              |
| -------- | ---------------- | ---------------- | ---------------- |
| **管道**   | 数据流单向，顺序传输       | 父子进程或兄弟进程之间通信    | 简单易用，但仅支持单向通信    |
| **消息队列** | 支持异步通信，先进先出队列    | 异步消息传递，多对多通信     | 支持结构化数据，适合复杂通信需求 |
| **共享内存** | 高效，多个进程共享同一内存区域  | 大量数据传输，实时通信      | 需要同步机制，避免竞争条件    |
| **信号量**  | 进程同步与互斥，控制共享资源访问 | 进程同步与互斥问题，防止竞争条件 | 仅解决同步问题，不直接传递数据  |
| **套接字**  | 跨进程，支持网络通信       | 分布式系统，网络通信       | 适用于远程通信，较为复杂     |
| **内存映射** | 进程共享文件，直接内存操作    | 大文件共享或高速数据处理     | 高效，但需要手动同步       |

### 7. Chatroom项目的修改
根据学长学姐后续提出的问题，主要进行了以下修改：
* 去除业务逻辑中的sleep与usleep等睡眠，加快业务效率，但保留了收发心跳的sleep。
* 将全部.hpp文件分为了.cpp和.h文件，重写cmake并处理编译问题，并对修改后的项目进行运行测试。